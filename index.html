<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Code Flow Puzzle</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
        color: #333;
      }

      h1 {
        color: #2c3e50;
      }

      .controls {
        margin-bottom: 20px;
        padding: 15px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-wrap: wrap; /* Allow wrapping for smaller screens */
        gap: 15px;
        align-items: center;
      }

      .controls label {
        margin-right: 5px;
      }

      .controls select,
      .controls input[type="number"],
      .controls button {
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid #ccc;
        font-size: 1em;
      }

      .controls input[type="number"] {
        width: 60px;
      }

      .controls button {
        background-color: #3498db;
        color: white;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .controls button:hover {
        background-color: #2980b9;
      }

      #puzzle-status {
        margin-bottom: 15px;
        font-size: 1.2em;
        font-weight: bold;
        color: #e67e22;
      }

      #puzzle-status.solved {
        color: #2ecc71;
      }

      #puzzle-container {
        margin-top: 10px; /* Added some margin */
      }

      .puzzle-grid {
        display: grid;
        border: 2px solid #34495e;
        background-color: #ecf0f1;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .tile {
        width: 50px;
        height: 50px;
        box-sizing: border-box;
        border: 1px solid #bdc3c7;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 28px;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s ease;
        background-color: #fff;
      }

      .tile:hover:not(.locked):not(.solved-state) {
        background-color: #e0e0e0;
      }

      .tile.locked {
        cursor: not-allowed;
        background-color: #d0d0d0;
        color: #7f8c8d;
      }

      .tile.start-tile,
      .tile.end-tile {
        font-weight: bold;
      }

      .tile.start-tile {
        background-color: #2ecc71;
        color: white;
      }

      .tile.end-tile {
        background-color: #e74c3c;
        color: white;
      }

      .tile.on-solution-path.solved-state {
        background-color: #a2f2c0;
      }
      .tile.solved-state:not(.on-solution-path) {
        background-color: #f5f5f5;
      }
    </style>
  </head>
  <body>
    <h1>Code Flow Puzzle</h1>

    <div class="controls">
      <label for="board-size">Rows:</label>
      <input type="number" id="board-size" value="5" min="3" max="15" />
      <label for="board-size-cols">Cols:</label>
      <input type="number" id="board-size-cols" value="5" min="3" max="15" />

      <label for="locked-level">Locked Tiles:</label>
      <select id="locked-level">
        <option value="0.1">Low (New Feature)</option>
        <option value="0.25" selected>Medium (Refactor)</option>
        <option value="0.4">High (Legacy Bugfix)</option>
      </select>

      <button id="start-puzzle">Start New Puzzle</button>
    </div>

    <div id="puzzle-status">Initialize a puzzle to begin!</div>
    <div id="puzzle-container">
      <!-- Puzzle grid will be rendered here by JS -->
    </div>

    <script>
      const TILE_DEFINITIONS = {
        I: {
          connections: [
            [true, false, true, false],
            [false, true, false, true],
          ],
          chars: ["│", "─"],
        },
        L: {
          connections: [
            [true, true, false, false],
            [false, true, true, false],
            [false, false, true, true],
            [true, false, false, true],
          ],
          chars: ["┘", "└", "┌", "┐"],
        },
        T: {
          connections: [
            [true, true, false, true],
            [true, true, true, false],
            [false, true, true, true],
            [true, false, true, true],
          ],
          chars: ["┤", "┴", "├", "┬"],
        },
        X: {
          connections: [[true, true, true, true]],
          chars: ["┼"],
        },
        START: {
          connections: [
            [false, true, false, false],
            [false, false, true, false],
            [false, false, false, true],
            [true, false, false, false],
          ], // Base connection: East, South, West, North (for rotations 0,1,2,3)
          chars: ["►", "▼", "◄", "▲"], // Rot 0 points E, Rot 1 points S, Rot 2 points W, Rot 3 points N
          isSpecial: true,
        },
        END: {
          connections: [
            [false, true, false, false],
            [false, false, true, false],
            [false, false, false, true],
            [true, false, false, false],
          ], // Same as START, defines which side is open
          chars: ["►", "▼", "◄", "▲"], // Visually same as START, but colored differently. Represents the 'input' side.
          isSpecial: true,
        },
      };

      let board = [];
      let numRows = 5;
      let numCols = 5;
      let lockedTilePercentage = 0.25;
      let startPos = { r: 0, c: 0 };
      let endPos = { r: 4, c: 4 };
      let gameSolved = false;
      let solutionPathCellsSet = new Set();

      const puzzleContainer = document.getElementById("puzzle-container");
      const puzzleStatusEl = document.getElementById("puzzle-status");
      const boardSizeRowsInput = document.getElementById("board-size");
      const boardSizeColsInput = document.getElementById("board-size-cols");
      const lockedLevelSelect = document.getElementById("locked-level");
      const startPuzzleButton = document.getElementById("start-puzzle");

      function getTileActualConnections(tile) {
        if (!tile || !tile.type || !TILE_DEFINITIONS[tile.type])
          return [false, false, false, false];
        const def = TILE_DEFINITIONS[tile.type];
        return def.connections[tile.rotation % def.connections.length];
      }

      function getTileChar(tile) {
        if (!tile || !tile.type || !TILE_DEFINITIONS[tile.type]) return " ";
        const def = TILE_DEFINITIONS[tile.type];
        return def.chars[tile.rotation % def.chars.length];
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function getNeighbors(r, c, rows, cols) {
        const neighbors = [];
        const dr = [-1, 0, 1, 0]; // N, E, S, W
        const dc = [0, 1, 0, -1];
        const dirs = [0, 1, 2, 3]; // 0:N, 1:E, 2:S, 3:W connection FROM current cell
        const oppositeDirs = [2, 3, 0, 1]; // Connection TO current cell from neighbor

        for (let i = 0; i < 4; i++) {
          const nr = r + dr[i];
          const nc = c + dc[i];
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            neighbors.push({
              r: nr,
              c: nc,
              dir: dirs[i],
              oppositeDir: oppositeDirs[i],
            });
          }
        }
        return neighbors;
      }

      function createSolutionPath(rows, cols, startR, startC, endR, endC) {
        const stack = [
          {
            r: startR,
            c: startC,
            pathCells: [
              {
                r: startR,
                c: startC,
                connections: [false, false, false, false],
              },
            ],
          },
        ];
        const visitedForPathfinding = new Set([`${startR}-${startC}`]);
        let generatedPathCells = null;

        while (stack.length > 0) {
          const current = stack.pop(); // Use DFS for potentially more complex paths
          const { r, c, pathCells } = current;

          if (r === endR && c === endC) {
            generatedPathCells = pathCells;
            break;
          }

          const neighbors = getNeighbors(r, c, rows, cols);
          shuffleArray(neighbors);

          for (const neighbor of neighbors) {
            if (!visitedForPathfinding.has(`${neighbor.r}-${neighbor.c}`)) {
              visitedForPathfinding.add(`${neighbor.r}-${neighbor.c}`);

              const newPathCells = pathCells.map((pc) => ({
                ...pc,
                connections: [...pc.connections],
              }));

              let currentCellInPath = newPathCells.find(
                (p) => p.r === r && p.c === c
              );
              currentCellInPath.connections[neighbor.dir] = true;

              let neighborCellInPath = newPathCells.find(
                (p) => p.r === neighbor.r && p.c === neighbor.c
              );
              if (!neighborCellInPath) {
                neighborCellInPath = {
                  r: neighbor.r,
                  c: neighbor.c,
                  connections: [false, false, false, false],
                };
                newPathCells.push(neighborCellInPath);
              }
              neighborCellInPath.connections[neighbor.oppositeDir] = true;

              stack.push({
                r: neighbor.r,
                c: neighbor.c,
                pathCells: newPathCells,
              });
            }
          }
        }

        if (!generatedPathCells) return null;

        const pathTilesData = {};
        for (const cell of generatedPathCells) {
          const { r, c, connections } = cell; // connections: [N, E, S, W] needed for this cell
          const numConnections = connections.filter((conn) => conn).length;
          let type, rotation;

          if (r === startR && c === startC) {
            type = "START";
            const exitDir = connections.indexOf(true); // The direction path EXITS the start tile
            // START chars: ['►', '▼', '◄', '▲'] for Rot 0(E), 1(S), 2(W), 3(N)
            if (exitDir === 0)
              rotation = 3; // Path exits North, START tile points North (▲)
            else if (exitDir === 1)
              rotation = 0; // Path exits East, START tile points East (►)
            else if (exitDir === 2)
              rotation = 1; // Path exits South, START tile points South (▼)
            else if (exitDir === 3)
              rotation = 2; // Path exits West, START tile points West (◄)
            else rotation = 0;
          } else if (r === endR && c === endC) {
            type = "END";
            const entryDir = connections.indexOf(true); // The direction path ENTERS the end tile (from its perspective)
            // END chars: ['►', '▼', '◄', '▲'] for Rot 0(E), 1(S), 2(W), 3(N) (which side is "open")
            // If path connects to END's North side (entryDir=0), END tile must point North (▲)
            if (entryDir === 0)
              rotation = 3; // Path enters END from South (connects to END's N side), END points N
            else if (entryDir === 1)
              rotation = 0; // Path enters END from West (connects to END's E side), END points E
            else if (entryDir === 2)
              rotation = 1; // Path enters END from North (connects to END's S side), END points S
            else if (entryDir === 3)
              rotation = 2; // Path enters END from East (connects to END's W side), END points W
            else rotation = 0;
          } else {
            if (numConnections === 2) {
              const [first, second] = connections
                .map((val, idx) => (val ? idx : -1))
                .filter((idx) => idx !== -1);
              if (Math.abs(first - second) === 2) {
                type = "I";
                rotation = first === 0 || first === 2 ? 0 : 1;
              } else {
                type = "L";
                if (connections[0] && connections[1]) rotation = 0; // N-E (┘)
                else if (connections[1] && connections[2])
                  rotation = 1; // E-S (└)
                else if (connections[2] && connections[3])
                  rotation = 2; // S-W (┌)
                else if (connections[0] && connections[3])
                  rotation = 3; // N-W (┐) (Note: W-N is same as N-W)
                else rotation = 0;
              }
            } else if (numConnections === 3) {
              type = "T";
              if (!connections[2]) rotation = 0; // N-E-W, open S (┤)
              else if (!connections[3]) rotation = 1; // N-E-S, open W (┴)
              else if (!connections[0]) rotation = 2; // E-S-W, open N (├)
              else if (!connections[1]) rotation = 3; // N-S-W, open E (┬)
              else rotation = 0;
            } else if (numConnections === 4) {
              type = "X";
              rotation = 0;
            } else {
              console.warn(
                `Path cell ${r},${c} has unexpected ${numConnections} connections. Defaulting to 'I'.`
              );
              type = "I";
              rotation = 0;
            }
          }
          pathTilesData[`${r}-${c}`] = { type, rotation, isPath: true };
        }
        return pathTilesData;
      }

      function generatePuzzle() {
        gameSolved = false;
        solutionPathCellsSet.clear();
        puzzleStatusEl.textContent = "Puzzle in progress...";
        puzzleStatusEl.className = "";

        // Define start/end positions
        if (numRows <= 3 && numCols <= 3) {
          // Fixed for small square grids (or rects where one dim is <=3)
          startPos = { r: 0, c: 0 };
          endPos = { r: numRows - 1, c: numCols - 1 };
        } else {
          startPos = {
            r: Math.floor(Math.random() * Math.floor(numRows / 2)),
            c: Math.floor(Math.random() * Math.floor(numCols / 2)),
          };
          endPos = {
            r:
              numRows - 1 - Math.floor(Math.random() * Math.floor(numRows / 2)),
            c:
              numCols - 1 - Math.floor(Math.random() * Math.floor(numCols / 2)),
          };
        }

        if (startPos.r === endPos.r && startPos.c === endPos.c) {
          if (numCols > 1) endPos.c = numCols - 1 - startPos.c;
          if (startPos.r === endPos.r && startPos.c === endPos.c && numRows > 1)
            endPos.r = numRows - 1 - startPos.r;
          if (startPos.r === endPos.r && startPos.c === endPos.c) {
            // If still same
            puzzleStatusEl.textContent =
              "Error: Cannot place start/end distinctly. Try larger grid or different dimensions.";
            return;
          }
        }

        // 1. Generate the core solution path and tile configurations for it.
        const solutionData = createSolutionPath(
          numRows,
          numCols,
          startPos.r,
          startPos.c,
          endPos.r,
          endPos.c
        );

        console.log("Solution path data:", solutionData);

        if (!solutionData) {
          puzzleStatusEl.textContent =
            "Error generating solution path. Try again or adjust size.";
          return;
        }

        board = Array(numRows)
          .fill(null)
          .map(() => Array(numCols).fill(null));
        const tileTypes = ["I", "L", "T", "X"]; // Available filler types

        // 2. Populate the board:
        //    - Place solution path tiles with their correct "solved" rotations.
        //    - Fill other tiles randomly.
        //    - Mark Start/End tiles as locked.
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const key = `${r}-${c}`;
            const isStart = r === startPos.r && c === startPos.c;
            const isEnd = r === endPos.r && c === endPos.c;

            if (solutionData[key]) {
              // This tile is on the pre-calculated solution path
              const { type, rotation } = solutionData[key];
              board[r][c] = {
                type: type,
                rotation: rotation, // This is the "solved" rotation for this path tile
                locked: isStart || isEnd, // Start/End tiles are locked by default
                isStart: isStart,
                isEnd: isEnd,
                onSolutionPath: true,
              };
            } else {
              // This tile is a "filler" tile
              const randomType =
                tileTypes[Math.floor(Math.random() * tileTypes.length)];
              const def = TILE_DEFINITIONS[randomType];
              const randomRotation = Math.floor(
                Math.random() * def.connections.length
              );
              board[r][c] = {
                type: randomType,
                rotation: randomRotation, // Initial random rotation
                locked: false,
                isStart: false,
                isEnd: false,
                onSolutionPath: false,
              };
            }
          }
        }

        // 3. Lock additional tiles based on difficulty percentage.
        //    Locked path tiles will retain their "solved" rotation.
        //    Locked filler tiles will retain their random rotation.
        const tilesToConsiderLocking = [];
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            if (!board[r][c].isStart && !board[r][c].isEnd) {
              tilesToConsiderLocking.push({
                r,
                c,
                onPath: board[r][c].onSolutionPath,
              });
            }
          }
        }
        shuffleArray(tilesToConsiderLocking);

        let numAdditionalLock = Math.floor(
          (numRows * numCols - 2) * lockedTilePercentage
        );
        let lockedCount = 0;

        // Prioritize locking on-path tiles for "legacy code" feel, then off-path
        const pathLockTargetRatio = 0.7; // Try to lock 70% of additional locks from path tiles

        for (const tileLoc of tilesToConsiderLocking) {
          if (lockedCount >= numAdditionalLock) break;

          let shouldLock = false;
          if (
            tileLoc.onPath &&
            numAdditionalLock * pathLockTargetRatio > lockedCount
          ) {
            // Heuristic
            shouldLock = true;
          } else if (!tileLoc.onPath) {
            shouldLock = true; // Lock off-path if on-path quota met or tile is off-path
          }
          // Fallback if initial locking strategy doesn't fill quota
          if (
            lockedCount < numAdditionalLock &&
            !board[tileLoc.r][tileLoc.c].locked
          ) {
            shouldLock = true;
          }

          if (shouldLock && !board[tileLoc.r][tileLoc.c].locked) {
            // Check again for safety
            board[tileLoc.r][tileLoc.c].locked = true;
            lockedCount++;
          }
        }
        // Ensure the quota is met if possible, from any remaining non-locked tiles
        for (const tileLoc of tilesToConsiderLocking) {
          if (lockedCount >= numAdditionalLock) break;
          if (!board[tileLoc.r][tileLoc.c].locked) {
            board[tileLoc.r][tileLoc.c].locked = true;
            lockedCount++;
          }
        }

        // 4. Scramble rotations of UNLOCKED non-start/end tiles.
        //    This is the step that "shuffles" the puzzle from its initial defined state.
        //    Because a solution path was explicitly constructed and locked tiles (including Start/End
        //    and any locked path tiles) retain their crucial rotations, the puzzle remains solvable.
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tile = board[r][c];
            // Only scramble if tile is not locked. Start/End are already locked with correct orientation.
            if (!tile.locked) {
              const def = TILE_DEFINITIONS[tile.type];
              tile.rotation = Math.floor(
                Math.random() * def.connections.length
              );
            }
          }
        }
        renderBoard();
        checkWinCondition();
      }

      function renderBoard() {
        puzzleContainer.innerHTML = "";
        const grid = document.createElement("div");
        grid.className = "puzzle-grid";
        grid.style.gridTemplateColumns = `repeat(${numCols}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${numRows}, 1fr)`;

        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tileData = board[r][c];
            const tileDiv = document.createElement("div");
            tileDiv.className = "tile";
            tileDiv.textContent = getTileChar(tileData);

            if (tileData.locked) tileDiv.classList.add("locked");
            if (tileData.isStart) tileDiv.classList.add("start-tile");
            if (tileData.isEnd) tileDiv.classList.add("end-tile");

            if (gameSolved) {
              tileDiv.classList.add("solved-state");
              if (solutionPathCellsSet.has(`${r}-${c}`)) {
                tileDiv.classList.add("on-solution-path");
              }
            }

            if (!tileData.locked && !gameSolved) {
              tileDiv.addEventListener("click", () => onTileClick(r, c));
            }
            grid.appendChild(tileDiv);
          }
        }
        puzzleContainer.appendChild(grid);
      }

      function onTileClick(r, c) {
        if (gameSolved || board[r][c].locked) return;

        const tile = board[r][c];
        const def = TILE_DEFINITIONS[tile.type];
        tile.rotation = (tile.rotation + 1) % def.connections.length;

        renderBoard();
        checkWinCondition();
      }

      function checkWinCondition() {
        solutionPathCellsSet.clear();

        const q = [];
        const visited = new Set();

        // Initial step from START tile
        const startTileObj = board[startPos.r][startPos.c];
        const startTileConnections = getTileActualConnections(startTileObj);

        for (let dir = 0; dir < 4; dir++) {
          // N, E, S, W
          if (startTileConnections[dir]) {
            // If START tile connects in this direction
            const dr = [-1, 0, 1, 0];
            const dc = [0, 1, 0, -1];
            const nr = startPos.r + dr[dir];
            const nc = startPos.c + dc[dir];

            if (nr >= 0 && nr < numRows && nc >= 0 && nc < numCols) {
              const neighborTile = board[nr][nc];
              const neighborConnections =
                getTileActualConnections(neighborTile);
              const oppositeDir = (dir + 2) % 4;
              if (neighborConnections[oppositeDir]) {
                // Neighbor connects back
                // Add neighbor to queue, marking startPos as the 'previous' for path reconstruction
                q.push({
                  r: nr,
                  c: nc,
                  path: [`${startPos.r}-${startPos.c}`, `${nr}-${nc}`],
                });
                visited.add(`${startPos.r}-${startPos.c}`); // Add start to visited BEFORE queue processing
                visited.add(`${nr}-${nc}`);
              }
            }
          }
        }

        let pathToEndFound = false;
        let finalPath = null;

        let head = 0;
        while (head < q.length) {
          const curr = q[head++]; // Dequeue
          const r = curr.r;
          const c = curr.c;

          if (r === endPos.r && c === endPos.c) {
            // We've reached the End tile's *position*.
            // The check that the End tile *accepts* this connection was implicitly done when adding it to queue.
            pathToEndFound = true;
            finalPath = curr.path;
            break;
          }

          const currentTileConnections = getTileActualConnections(board[r][c]);
          const dr = [-1, 0, 1, 0];
          const dc = [0, 1, 0, -1];

          for (let dir = 0; dir < 4; dir++) {
            if (currentTileConnections[dir]) {
              const nr = r + dr[dir];
              const nc = c + dc[dir];

              if (
                nr >= 0 &&
                nr < numRows &&
                nc >= 0 &&
                nc < numCols &&
                !visited.has(`${nr}-${nc}`)
              ) {
                const neighborTile = board[nr][nc];
                const neighborConnections =
                  getTileActualConnections(neighborTile);
                const oppositeDir = (dir + 2) % 4;

                if (neighborConnections[oppositeDir]) {
                  visited.add(`${nr}-${nc}`);
                  const newPath = [...curr.path, `${nr}-${nc}`];
                  q.push({ r: nr, c: nc, path: newPath });
                }
              }
            }
          }
        }

        if (!pathToEndFound) {
          gameSolved = false;
          // Do not change status if it's the initial call and puzzle is not yet solved
          if (puzzleStatusEl.textContent.includes("Solved!")) {
            puzzleStatusEl.textContent = "Puzzle in progress...";
            puzzleStatusEl.className = "";
          }
          return false;
        }

        finalPath.forEach((p) => solutionPathCellsSet.add(p));

        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tile = board[r][c];
            const connections = getTileActualConnections(tile);
            const dr = [-1, 0, 1, 0];
            const dc = [0, 1, 0, -1];

            for (let dir = 0; dir < 4; dir++) {
              if (connections[dir]) {
                const nr = r + dr[dir];
                const nc = c + dc[dir];

                if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) {
                  gameSolved = false; // Opening to outside grid edge is a leak
                  if (puzzleStatusEl.textContent.includes("Solved!")) {
                    puzzleStatusEl.textContent = "Leak detected!";
                    puzzleStatusEl.className = "";
                  }
                  return false;
                }

                const neighborTile = board[nr][nc];
                const neighborConnections =
                  getTileActualConnections(neighborTile);
                const oppositeDir = (dir + 2) % 4;

                if (!neighborConnections[oppositeDir]) {
                  gameSolved = false; // Neighbor doesn't connect back
                  if (puzzleStatusEl.textContent.includes("Solved!")) {
                    puzzleStatusEl.textContent = "Leak detected!";
                    puzzleStatusEl.className = "";
                  }
                  return false;
                }
              }
            }
          }
        }

        gameSolved = true;
        puzzleStatusEl.textContent = "Solved!";
        puzzleStatusEl.className = "solved";
        renderBoard();
        return true;
      }

      startPuzzleButton.addEventListener("click", () => {
        numRows = parseInt(boardSizeRowsInput.value);
        numCols = parseInt(boardSizeColsInput.value);
        if (isNaN(numRows) || numRows < 3 || numRows > 15) {
          alert("Board rows must be between 3 and 15.");
          boardSizeRowsInput.value = String(
            Math.max(3, Math.min(15, numRows || 5))
          );
          return;
        }
        if (isNaN(numCols) || numCols < 3 || numCols > 15) {
          alert("Board columns must be between 3 and 15.");
          boardSizeColsInput.value = String(
            Math.max(3, Math.min(15, numCols || 5))
          );
          return;
        }
        lockedTilePercentage = parseFloat(lockedLevelSelect.value);
        generatePuzzle();
      });

      // Initial puzzle
      generatePuzzle();
    </script>
  </body>
</html>
