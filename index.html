<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Code Flow Puzzle</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px;
      }
      h1 {
        margin-bottom: 10px;
      }
      #controls {
        margin-bottom: 15px;
      }
      #controls input {
        width: 50px;
        margin: 0 5px;
      }
      #puzzle {
        background: #f0f0f0;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      }
    </style>
  </head>
  <body>
    <h1>Code Flow Puzzle</h1>
    <div id="controls">
      Grid Size:
      <input id="size" type="number" min="3" max="10" value="5" />
      Locked %:
      <input id="locked" type="number" min="0" max="100" value="20" />
      <button id="generate">Generate Puzzle</button>
    </div>
    <canvas id="puzzle"></canvas>

    <script>
      const canvas = document.getElementById("puzzle");
      const ctx = canvas.getContext("2d");
      const TILE = 60;

      let grid = [],
        N,
        lockedPercent;

      function initPuzzle() {
        N = parseInt(document.getElementById("size").value);
        lockedPercent = parseInt(document.getElementById("locked").value);
        canvas.width = canvas.height = N * TILE;
        // build snake‚Äêpath Hamiltonian chain
        const cells = [];
        for (let r = 0; r < N; r++) {
          if (r % 2 === 0) {
            for (let c = 0; c < N; c++) cells.push([r, c]);
          } else {
            for (let c = N - 1; c >= 0; c--) cells.push([r, c]);
          }
        }
        // neighbor map
        const dirs = {
          up: [-1, 0],
          right: [0, 1],
          down: [1, 0],
          left: [0, -1],
        };
        grid = Array.from({ length: N }, () => Array(N).fill(null));
        for (let i = 0; i < cells.length; i++) {
          const [r, c] = cells[i];
          const conns = [];
          if (i > 0) {
            const [pr, pc] = cells[i - 1];
            for (let d in dirs) {
              if (pr === r + dirs[d][0] && pc === c + dirs[d][1]) conns.push(d);
            }
          }
          if (i < cells.length - 1) {
            const [nr, nc] = cells[i + 1];
            for (let d in dirs) {
              if (nr === r + dirs[d][0] && nc === c + dirs[d][1]) conns.push(d);
            }
          }
          // determine type and correct rotation
          let type, correct;
          if (conns.length === 1) {
            type = "end";
            correct = rotateFor(["right"], conns);
          } else {
            // straight if opposite, else curve
            if (
              (conns.includes("left") && conns.includes("right")) ||
              (conns.includes("up") && conns.includes("down"))
            )
              type = "straight";
            else type = "curve";
            correct = rotateFor(
              type === "straight" ? ["right", "left"] : ["up", "right"],
              conns
            );
          }
          // locked?
          const locked = Math.random() * 100 < lockedPercent;
          const rot = locked
            ? correct
            : (correct + (Math.floor(Math.random() * 3) + 1) * 90) % 360;
          grid[r][c] = {
            type,
            correct,
            rotation: rot,
            locked,
            special: i === 0 ? "start" : i === cells.length - 1 ? "end" : null,
          };
        }
        draw();
      }

      // compute rotation to get default dirs ‚Üí target conns
      // default: straight=['right','left'], curve=['up','right'], end=['right']
      function rotateFor(def, target) {
        const order = [0, 90, 180, 270];
        for (let ang of order) {
          const got = def.map((d) => rotateDir(d, ang)).sort();
          if (arraysEqual(got.sort(), target.sort())) return ang;
        }
        return 0;
      }
      function rotateDir(d, ang) {
        const list = ["up", "right", "down", "left"];
        return list[(list.indexOf(d) + ang / 90) % 4];
      }
      function arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
        return true;
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < N; r++)
          for (let c = 0; c < N; c++) {
            const x = c * TILE,
              y = r * TILE;
            const t = grid[r][c];
            ctx.save();
            ctx.translate(x + TILE / 2, y + TILE / 2);
            ctx.rotate((t.rotation * Math.PI) / 180);
            // draw pipe
            ctx.lineWidth = TILE / 5;
            ctx.lineCap = "butt";
            ctx.strokeStyle = t.locked ? "#888" : "#3498db";
            if (t.type === "straight") {
              ctx.beginPath();
              ctx.moveTo(-TILE / 2 + 5, 0);
              ctx.lineTo(TILE / 2 - 5, 0);
              ctx.stroke();
            } else if (t.type === "curve") {
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(0, -TILE / 2 + 5);
              ctx.moveTo(0, 0);
              ctx.lineTo(TILE / 2 - 5, 0);
              ctx.stroke();
            } else if (t.type === "end") {
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(TILE / 2 - 5, 0);
              ctx.stroke();
            }
            // special markers
            if (t.special === "start") {
              ctx.fillStyle = "green";
              ctx.beginPath();
              ctx.arc(0, 0, TILE / 6, 0, 2 * Math.PI);
              ctx.fill();
            } else if (t.special === "end") {
              ctx.fillStyle = "red";
              ctx.beginPath();
              ctx.arc(0, 0, TILE / 6, 0, 2 * Math.PI);
              ctx.fill();
            }
            ctx.restore();
          }
      }

      function checkSolution() {
        // build map of connections
        const dirVec = {
          up: [-1, 0],
          right: [0, 1],
          down: [1, 0],
          left: [0, -1],
        };
        for (let r = 0; r < N; r++)
          for (let c = 0; c < N; c++) {
            const t = grid[r][c];
            // get its current dirs
            const def =
              t.type === "straight"
                ? ["right", "left"]
                : t.type === "curve"
                ? ["up", "right"]
                : ["right"];
            const now = def.map((d) => rotateDir(d, t.rotation));
            // must match degree: ends degree1, others degree2
            if ((t.special ? "endOrStart" : "normal") === "normal") {
              if (now.length !== 2) return false;
            } else {
              if (now.length !== 1) return false;
            }
            // adjacency check
            for (let d of now) {
              const [dr, dc] = dirVec[d];
              const nr = r + dr,
                nc = c + dc;
              if (nr < 0 || nr >= N || nc < 0 || nc >= N) return false;
              const other = grid[nr][nc];
              // check other has opposite
              const opp = {
                up: "down",
                down: "up",
                left: "right",
                right: "left",
              }[d];
              const odef =
                other.type === "straight"
                  ? ["right", "left"]
                  : other.type === "curve"
                  ? ["up", "right"]
                  : ["right"];
              const onow = odef.map((dd) => rotateDir(dd, other.rotation));
              if (!onow.includes(opp)) return false;
            }
          }
        return true;
      }

      canvas.addEventListener("click", (e) => {
        const c = Math.floor(e.offsetX / TILE);
        const r = Math.floor(e.offsetY / TILE);
        if (r >= 0 && r < N && c >= 0 && c < N) {
          const t = grid[r][c];
          if (!t.locked) {
            t.rotation = (t.rotation + 90) % 360;
            draw();
            if (checkSolution()) {
              setTimeout(() => alert("üéâ Puzzle solved!"), 50);
            }
          }
        }
      });

      document.getElementById("generate").onclick = initPuzzle;
      // initial
      initPuzzle();
    </script>
  </body>
</html>
