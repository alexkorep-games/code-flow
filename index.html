<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Code Flow Puzzle</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
        color: #333;
      }

      h1 {
        color: #2c3e50;
      }

      .controls {
        margin-bottom: 20px;
        padding: 15px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .controls label {
        margin-right: 5px;
      }

      .controls select,
      .controls input[type="number"],
      .controls button {
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid #ccc;
        font-size: 1em;
      }

      .controls input[type="number"] {
        width: 60px;
      }

      .controls button {
        background-color: #3498db;
        color: white;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .controls button:hover {
        background-color: #2980b9;
      }

      #puzzle-status {
        margin-bottom: 15px;
        font-size: 1.2em;
        font-weight: bold;
        color: #e67e22;
      }

      #puzzle-status.solved {
        color: #2ecc71;
      }

      .puzzle-grid {
        display: grid;
        border: 2px solid #34495e;
        background-color: #ecf0f1;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .tile {
        width: 50px;
        height: 50px;
        box-sizing: border-box;
        border: 1px solid #bdc3c7;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 28px; /* Adjust for unicode character size */
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s ease;
        background-color: #fff;
      }

      .tile:hover:not(.locked):not(.solved-state) {
        background-color: #e0e0e0;
      }

      .tile.locked {
        cursor: not-allowed;
        background-color: #d0d0d0; /* Light gray for locked */
        color: #7f8c8d;
      }

      .tile.start-tile,
      .tile.end-tile {
        font-weight: bold;
      }

      .tile.start-tile {
        background-color: #2ecc71; /* Greenish */
        color: white;
      }

      .tile.end-tile {
        background-color: #e74c3c; /* Reddish */
        color: white;
      }

      /* For highlighting solved path if desired */
      .tile.on-solution-path.solved-state {
        background-color: #a2f2c0; /* Light green for path */
      }
      .tile.solved-state:not(.on-solution-path) {
        background-color: #f5f5f5; /* Slightly off-white for non-path tiles when solved */
      }
    </style>
  </head>
  <body>
    <h1>Code Flow Puzzle</h1>

    <div class="controls">
      <label for="board-size">Board Size:</label>
      <input type="number" id="board-size" value="5" min="3" max="15" />
      <span>x</span>
      <input type="number" id="board-size-cols" value="5" min="3" max="15" />

      <label for="locked-level">Locked Tiles:</label>
      <select id="locked-level">
        <option value="0.1">Low (New Feature)</option>
        <option value="0.25" selected>Medium (Refactor)</option>
        <option value="0.4">High (Legacy Bugfix)</option>
      </select>

      <button id="start-puzzle">Start New Puzzle</button>
    </div>

    <div id="puzzle-status">Initialize a puzzle to begin!</div>
    <div id="puzzle-container">
      <!-- Puzzle grid will be rendered here by JS -->
    </div>

    <script>
      const TILE_DEFINITIONS = {
        // Connections: [N, E, S, W] boolean array for open sides
        // Chars: Array of Unicode characters for each rotation
        I: {
          connections: [
            [true, false, true, false],
            [false, true, false, true],
          ],
          chars: ["│", "─"],
        },
        L: {
          connections: [
            [true, true, false, false],
            [false, true, true, false],
            [false, false, true, true],
            [true, false, false, true],
          ],
          chars: ["┘", "└", "┌", "┐"], // N-E, E-S, S-W, W-N
        },
        T: {
          connections: [
            [true, true, false, true],
            [true, true, true, false],
            [false, true, true, true],
            [true, false, true, true],
          ],
          chars: ["┤", "┴", "├", "┬"], // N-E-W (T points S), N-E-S (T points W), E-S-W (T points N), N-S-W (T points E)
        },
        X: {
          connections: [[true, true, true, true]],
          chars: ["┼"],
        },
        START: {
          connections: [
            [false, true, false, false],
            [false, false, true, false],
            [false, false, false, true],
            [true, false, false, false],
          ],
          chars: ["►", "▼", "◄", "▲"], // Points E, S, W, N
          isSpecial: true,
        },
        END: {
          connections: [
            [false, true, false, false],
            [false, false, true, false],
            [false, false, false, true],
            [true, false, false, false],
          ],
          chars: ["⦿", "⦿", "⦿", "⦿"], // Using a generic 'target' symbol, actual connection logic is key. Could use arrows too like START.
          // Using same arrows as START but will be colored differently: ['►', '▼', '◄', '▲']
          isSpecial: true,
        },
      };

      // Make END chars distinct if using arrows
      TILE_DEFINITIONS.END.chars = TILE_DEFINITIONS.START.chars.map((c) => c); // ['⦿', '⦿', '⦿', '⦿'] or copy arrows

      let board = [];
      let numRows = 5;
      let numCols = 5;
      let lockedTilePercentage = 0.25;
      let startPos = { r: 0, c: 0 };
      let endPos = { r: 4, c: 4 };
      let gameSolved = false;
      let solutionPathCellsSet = new Set(); // To store "r-c" strings of cells in the solution path

      const puzzleContainer = document.getElementById("puzzle-container");
      const puzzleStatusEl = document.getElementById("puzzle-status");
      const boardSizeRowsInput = document.getElementById("board-size");
      const boardSizeColsInput = document.getElementById("board-size-cols");
      const lockedLevelSelect = document.getElementById("locked-level");
      const startPuzzleButton = document.getElementById("start-puzzle");

      function getTileActualConnections(tile) {
        if (!tile || !tile.type || !TILE_DEFINITIONS[tile.type])
          return [false, false, false, false];
        const def = TILE_DEFINITIONS[tile.type];
        return def.connections[tile.rotation % def.connections.length];
      }

      function getTileChar(tile) {
        if (!tile || !tile.type || !TILE_DEFINITIONS[tile.type]) return " ";
        const def = TILE_DEFINITIONS[tile.type];
        return def.chars[tile.rotation % def.chars.length];
      }

      // --- Puzzle Generation ---
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function getNeighbors(r, c, rows, cols, includeDiagonals = false) {
        const neighbors = [];
        // N, E, S, W
        const dr = [-1, 0, 1, 0];
        const dc = [0, 1, 0, -1];
        const dirs = [0, 1, 2, 3]; // 0:N, 1:E, 2:S, 3:W
        const oppositeDirs = [2, 3, 0, 1];

        for (let i = 0; i < 4; i++) {
          const nr = r + dr[i];
          const nc = c + dc[i];
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            neighbors.push({
              r: nr,
              c: nc,
              dir: dirs[i],
              oppositeDir: oppositeDirs[i],
            });
          }
        }
        // Add diagonal later if needed
        return neighbors;
      }

      function createSolutionPath(rows, cols, startR, startC, endR, endC) {
        const stack = [
          {
            r: startR,
            c: startC,
            pathCells: [
              {
                r: startR,
                c: startC,
                connections: [false, false, false, false],
              },
            ],
          },
        ];
        const visitedForPathfinding = new Set([`${startR}-${startC}`]);
        let generatedPathCells = null;

        while (stack.length > 0) {
          const { r, c, pathCells } = stack.pop();

          if (r === endR && c === endC) {
            generatedPathCells = pathCells;
            break;
          }

          const neighbors = getNeighbors(r, c, rows, cols);
          shuffleArray(neighbors);

          for (const neighbor of neighbors) {
            if (!visitedForPathfinding.has(`${neighbor.r}-${neighbor.c}`)) {
              visitedForPathfinding.add(`${neighbor.r}-${neighbor.c}`);

              const newPathCells = pathCells.map((pc) => ({
                ...pc,
                connections: [...pc.connections],
              })); // Deep copy path cells

              let currentCellInPath = newPathCells.find(
                (p) => p.r === r && p.c === c
              );
              if (!currentCellInPath) {
                // Should not happen if logic is correct
                currentCellInPath = {
                  r,
                  c,
                  connections: [false, false, false, false],
                };
                newPathCells.push(currentCellInPath); // Should be there already
              }
              currentCellInPath.connections[neighbor.dir] = true;

              let neighborCellInPath = newPathCells.find(
                (p) => p.r === neighbor.r && p.c === neighbor.c
              );
              if (!neighborCellInPath) {
                neighborCellInPath = {
                  r: neighbor.r,
                  c: neighbor.c,
                  connections: [false, false, false, false],
                };
                newPathCells.push(neighborCellInPath);
              }
              neighborCellInPath.connections[neighbor.oppositeDir] = true;

              stack.push({
                r: neighbor.r,
                c: neighbor.c,
                pathCells: newPathCells,
              });
            }
          }
        }

        if (!generatedPathCells) return null;

        const pathTilesData = {};
        for (const cell of generatedPathCells) {
          const { r, c, connections } = cell;
          const numConnections = connections.filter((conn) => conn).length;
          let type, rotation;

          if (r === startR && c === startC) {
            type = "START";
            const dir = connections.indexOf(true); // Direction START tile points
            // START base is E [F,T,F,F]. Rotations: E=0, S=1, W=2, N=3
            if (dir === 0) rotation = 3; // N
            else if (dir === 1) rotation = 0; // E
            else if (dir === 2) rotation = 1; // S
            else if (dir === 3) rotation = 2; // W
            else rotation = 0; // Fallback if no connection (error)
          } else if (r === endR && c === endC) {
            type = "END";
            const dir = connections.indexOf(true); // Direction END tile receives from
            // END base is E [F,T,F,F] (points East).
            // If path enters from N (dir=0), END needs to point N. Rotation = 3.
            // If path enters from E (dir=1), END needs to point E. Rotation = 0.
            // If path enters from S (dir=2), END needs to point S. Rotation = 1.
            // If path enters from W (dir=3), END needs to point W. Rotation = 2.
            if (dir === 0) rotation = 3; // Accepts from S, points N
            else if (dir === 1) rotation = 0; // Accepts from W, points E
            else if (dir === 2) rotation = 1; // Accepts from N, points S
            else if (dir === 3) rotation = 2; // Accepts from E, points W
            else rotation = 0; // Fallback
          } else {
            if (numConnections === 2) {
              const [first, second] = connections
                .map((val, idx) => (val ? idx : -1))
                .filter((idx) => idx !== -1);
              if (Math.abs(first - second) === 2) {
                // Opposite: 'I'
                type = "I";
                rotation = first === 0 || first === 2 ? 0 : 1; // N-S is rot 0 (char '│'), E-W is rot 1 (char '─')
              } else {
                // Adjacent: 'L'
                type = "L";
                // L chars: ['┘', '└', '┌', '┐'] for N-E, E-S, S-W, W-N connections
                if (connections[0] && connections[1]) rotation = 0; // N-E
                else if (connections[1] && connections[2]) rotation = 1; // E-S
                else if (connections[2] && connections[3]) rotation = 2; // S-W
                else if (connections[3] && connections[0]) rotation = 3; // W-N
                else rotation = 0; // Fallback
              }
            } else if (numConnections === 3) {
              type = "T";
              // T chars: ['┤', '┴', '├', '┬'] for N-E-W (open S), N-E-S (open W), E-S-W (open N), N-S-W (open E)
              if (connections[0] && connections[1] && connections[3])
                rotation = 0; // N,E,W connected (T points S)
              else if (connections[0] && connections[1] && connections[2])
                rotation = 1; // N,E,S connected (T points W)
              else if (connections[1] && connections[2] && connections[3])
                rotation = 2; // E,S,W connected (T points N)
              else if (connections[0] && connections[2] && connections[3])
                rotation = 3; // N,S,W connected (T points E)
              else rotation = 0; // Fallback
            } else if (numConnections === 4) {
              type = "X";
              rotation = 0;
            } else {
              // Includes numConnections === 1, which is an error for an internal path tile
              console.warn(
                `Path cell ${r},${c} has unexpected ${numConnections} connections. Defaulting to 'I'.`
              );
              type = "I";
              rotation = 0; // Fallback
            }
          }
          pathTilesData[`${r}-${c}`] = { type, rotation, isPath: true };
        }
        return pathTilesData;
      }

      function generatePuzzle() {
        gameSolved = false;
        solutionPathCellsSet.clear();
        puzzleStatusEl.textContent = "Puzzle in progress...";
        puzzleStatusEl.className = "";

        // Define start/end positions
        // For simplicity, Start top-left quadrant, End bottom-right quadrant.
        // Ensure they are reasonably spaced for smaller grids.
        startPos = {
          r: Math.floor(Math.random() * Math.floor(numRows / 2)),
          c: Math.floor(Math.random() * Math.floor(numCols / 2)),
        };
        endPos = {
          r: numRows - 1 - Math.floor(Math.random() * Math.floor(numRows / 2)),
          c: numCols - 1 - Math.floor(Math.random() * Math.floor(numCols / 2)),
        };

        // Ensure start and end are not the same, especially on small grids
        if (numRows <= 3 || numCols <= 3) {
          // Fixed for small grids
          startPos = { r: 0, c: 0 };
          endPos = { r: numRows - 1, c: numCols - 1 };
        }
        if (startPos.r === endPos.r && startPos.c === endPos.c) {
          // If they still end up same (e.g. very small grid)
          endPos.c = numCols - 1 - startPos.c; // Try to make them different
          if (startPos.r === endPos.r && startPos.c === endPos.c) {
            // if still same
            endPos.r = numRows - 1 - startPos.r;
          }
        }
        if (startPos.r === endPos.r && startPos.c === endPos.c && numCols > 1)
          endPos.c = (startPos.c + 1) % numCols;
        else if (
          startPos.r === endPos.r &&
          startPos.c === endPos.c &&
          numRows > 1
        )
          endPos.r = (startPos.r + 1) % numRows;

        if (startPos.r === endPos.r && startPos.c === endPos.c) {
          puzzleStatusEl.textContent =
            "Error: Cannot place start/end distinctly. Try larger grid.";
          return;
        }

        const solutionData = createSolutionPath(
          numRows,
          numCols,
          startPos.r,
          startPos.c,
          endPos.r,
          endPos.c
        );

        if (!solutionData) {
          puzzleStatusEl.textContent =
            "Error generating solution path. Try again or adjust size.";
          return;
        }

        board = Array(numRows)
          .fill(null)
          .map(() => Array(numCols).fill(null));
        const tileTypes = ["I", "L", "T", "X"];

        // Place solution path tiles
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const key = `${r}-${c}`;
            const isStart = r === startPos.r && c === startPos.c;
            const isEnd = r === endPos.r && c === endPos.c;

            if (solutionData[key]) {
              const { type, rotation } = solutionData[key];
              board[r][c] = {
                type: type,
                rotation: rotation,
                locked: isStart || isEnd, // Start/End tiles are locked by default
                isStart: isStart,
                isEnd: isEnd,
                onSolutionPath: true, // Mark as part of the original solution
              };
            } else {
              // Fill non-path tiles randomly
              const randomType =
                tileTypes[Math.floor(Math.random() * tileTypes.length)];
              const def = TILE_DEFINITIONS[randomType];
              const randomRotation = Math.floor(
                Math.random() * def.connections.length
              );
              board[r][c] = {
                type: randomType,
                rotation: randomRotation,
                locked: false,
                isStart: false,
                isEnd: false,
                onSolutionPath: false,
              };
            }
          }
        }

        // Lock additional tiles
        const tilesToConsiderLocking = [];
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            if (!board[r][c].isStart && !board[r][c].isEnd) {
              tilesToConsiderLocking.push({
                r,
                c,
                onPath: board[r][c].onSolutionPath,
              });
            }
          }
        }
        shuffleArray(tilesToConsiderLocking);

        // Prioritize locking on-path tiles for "legacy code" feel
        const onPathTiles = tilesToConsiderLocking.filter((t) => t.onPath);
        const offPathTiles = tilesToConsiderLocking.filter((t) => !t.onPath);

        let numToLock = Math.floor(
          (numRows * numCols - 2) * lockedTilePercentage
        ); // -2 for start/end

        let lockedCount = 0;
        // Lock ~70% from path, ~30% from off-path, if available
        const pathLockTarget = Math.ceil(numToLock * 0.7);
        const offPathLockTarget = numToLock - pathLockTarget;

        for (
          let i = 0;
          i < onPathTiles.length &&
          lockedCount < pathLockTarget &&
          numToLock > 0;
          i++
        ) {
          board[onPathTiles[i].r][onPathTiles[i].c].locked = true;
          lockedCount++;
          numToLock--;
        }
        for (let i = 0; i < offPathTiles.length && numToLock > 0; i++) {
          board[offPathTiles[i].r][offPathTiles[i].c].locked = true;
          lockedCount++;
          numToLock--;
        }

        // Scramble rotations of UNLOCKED non-start/end tiles
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tile = board[r][c];
            if (!tile.locked && !tile.isStart && !tile.isEnd) {
              const def = TILE_DEFINITIONS[tile.type];
              tile.rotation = Math.floor(
                Math.random() * def.connections.length
              );
            }
          }
        }
        renderBoard();
        checkWinCondition(); // Check initial state (usually not solved)
      }

      // --- Rendering ---
      function renderBoard() {
        puzzleContainer.innerHTML = "";
        const grid = document.createElement("div");
        grid.className = "puzzle-grid";
        grid.style.gridTemplateColumns = `repeat(${numCols}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${numRows}, 1fr)`;

        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tileData = board[r][c];
            const tileDiv = document.createElement("div");
            tileDiv.className = "tile";
            tileDiv.textContent = getTileChar(tileData);

            if (tileData.locked) tileDiv.classList.add("locked");
            if (tileData.isStart) tileDiv.classList.add("start-tile");
            if (tileData.isEnd) tileDiv.classList.add("end-tile");

            if (gameSolved) {
              tileDiv.classList.add("solved-state");
              if (solutionPathCellsSet.has(`${r}-${c}`)) {
                tileDiv.classList.add("on-solution-path");
              }
            }

            if (!tileData.locked && !gameSolved) {
              tileDiv.addEventListener("click", () => onTileClick(r, c));
            }
            grid.appendChild(tileDiv);
          }
        }
        puzzleContainer.appendChild(grid);
      }

      // --- Interaction ---
      function onTileClick(r, c) {
        if (gameSolved || board[r][c].locked) return;

        const tile = board[r][c];
        const def = TILE_DEFINITIONS[tile.type];
        tile.rotation = (tile.rotation + 1) % def.connections.length;

        renderBoard(); // Could optimize to re-render only the clicked tile
        checkWinCondition();
      }

      // --- Win Condition Check ---
      function checkWinCondition() {
        solutionPathCellsSet.clear(); // Clear previous solution path highlighting

        // 1. BFS/DFS from Start to End
        const q = [
          {
            r: startPos.r,
            c: startPos.c,
            path: [`${startPos.r}-${startPos.c}`],
          },
        ];
        const visited = new Set([`${startPos.r}-${startPos.c}`]);
        let pathToEndFound = false;
        let finalPath = null;

        const startTileConnections = getTileActualConnections(
          board[startPos.r][startPos.c]
        );

        // Initial step from START tile: must connect according to its orientation
        for (let dir = 0; dir < 4; dir++) {
          // N, E, S, W
          if (startTileConnections[dir]) {
            const dr = [-1, 0, 1, 0];
            const dc = [0, 1, 0, -1];
            const nr = startPos.r + dr[dir];
            const nc = startPos.c + dc[dir];

            if (nr >= 0 && nr < numRows && nc >= 0 && nc < numCols) {
              const neighborTile = board[nr][nc];
              const neighborConnections =
                getTileActualConnections(neighborTile);
              const oppositeDir = (dir + 2) % 4;
              if (neighborConnections[oppositeDir]) {
                // Neighbor connects back
                q.push({
                  r: nr,
                  c: nc,
                  path: [`${startPos.r}-${startPos.c}`, `${nr}-${nc}`],
                });
                visited.add(`${nr}-${nc}`);
              }
            }
          }
        }
        // The queue q now contains the first valid neighbors of START tile.
        // We actually only need one starting point for BFS, so let's adjust.
        // Corrected BFS start:
        q.length = 0; // Clear queue
        visited.clear();

        q.push({
          r: startPos.r,
          c: startPos.c,
          path: [`${startPos.r}-${startPos.c}`],
        });
        visited.add(`${startPos.r}-${startPos.c}`);

        while (q.length > 0) {
          const curr = q.shift();
          const r = curr.r;
          const c = curr.c;

          if (r === endPos.r && c === endPos.c) {
            // Reached End Position
            // Now check if the END tile actually connects to the path from `curr.prev_r, curr.prev_c`
            // This is implicitly handled by how neighbors are added.
            // The crucial part is that the END tile's specific connection port must be used.
            // Let's refine this: the check for END tile connection is part of neighbor check.
            pathToEndFound = true;
            finalPath = curr.path;
            break;
          }

          const currentTileConnections = getTileActualConnections(board[r][c]);
          const dr = [-1, 0, 1, 0]; // N, E, S, W
          const dc = [0, 1, 0, -1];

          for (let dir = 0; dir < 4; dir++) {
            if (currentTileConnections[dir]) {
              // If current tile has an opening in this direction
              const nr = r + dr[dir];
              const nc = c + dc[dir];

              if (
                nr >= 0 &&
                nr < numRows &&
                nc >= 0 &&
                nc < numCols &&
                !visited.has(`${nr}-${nc}`)
              ) {
                const neighborTile = board[nr][nc];
                const neighborConnections =
                  getTileActualConnections(neighborTile);
                const oppositeDir = (dir + 2) % 4;

                if (neighborConnections[oppositeDir]) {
                  // If neighbor connects back
                  if (nr === endPos.r && nc === endPos.c) {
                    // If this neighbor is the END tile
                    // Check if this connection is THE one the END tile expects
                    const endTileExpectedConnectionDir =
                      neighborConnections.indexOf(true); // END tiles have one true connection
                    if (endTileExpectedConnectionDir === oppositeDir) {
                      visited.add(`${nr}-${nc}`);
                      const newPath = [...curr.path, `${nr}-${nc}`];
                      q.push({ r: nr, c: nc, path: newPath });
                    }
                  } else if (!neighborTile.isEnd) {
                    // Don't traverse non-end tiles if they are not connected properly
                    visited.add(`${nr}-${nc}`);
                    const newPath = [...curr.path, `${nr}-${nc}`];
                    q.push({ r: nr, c: nc, path: newPath });
                  }
                }
              }
            }
          }
        }

        if (!pathToEndFound) {
          gameSolved = false;
          if (puzzleStatusEl.textContent.includes("Solved")) {
            // Avoid overwriting initial messages
            puzzleStatusEl.textContent = "Puzzle in progress...";
            puzzleStatusEl.className = "";
          }
          return false;
        }

        // Store the found path for highlighting
        finalPath.forEach((p) => solutionPathCellsSet.add(p));

        // 2. "Fully routed" check (no leaks on the ENTIRE grid)
        for (let r = 0; r < numRows; r++) {
          for (let c = 0; c < numCols; c++) {
            const tile = board[r][c];
            const connections = getTileActualConnections(tile);
            const dr = [-1, 0, 1, 0];
            const dc = [0, 1, 0, -1];

            for (let dir = 0; dir < 4; dir++) {
              // For each direction N,E,S,W
              if (connections[dir]) {
                // If this tile has an opening in 'dir'
                const nr = r + dr[dir];
                const nc = c + dc[dir];

                if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) {
                  // Opening to outside grid edge
                  // This is a leak, UNLESS it's the designated port of Start/End.
                  // But Start/End are designed to connect inwards. So this is always a leak.
                  gameSolved = false;
                  return false;
                }

                // Neighbor is on grid, check if it connects back
                const neighborTile = board[nr][nc];
                const neighborConnections =
                  getTileActualConnections(neighborTile);
                const oppositeDir = (dir + 2) % 4;

                if (!neighborConnections[oppositeDir]) {
                  // Neighbor doesn't connect back
                  gameSolved = false;
                  return false;
                }
              }
            }
          }
        }

        // If all checks pass
        gameSolved = true;
        puzzleStatusEl.textContent = "Solved!";
        puzzleStatusEl.className = "solved";
        renderBoard(); // Re-render to apply solved styles
        return true;
      }

      // --- Setup ---
      startPuzzleButton.addEventListener("click", () => {
        numRows = parseInt(boardSizeRowsInput.value);
        numCols = parseInt(boardSizeColsInput.value);
        if (isNaN(numRows) || numRows < 3 || numRows > 15) {
          alert("Board rows must be between 3 and 15.");
          boardSizeRowsInput.value = Math.max(3, Math.min(15, numRows || 5));
          return;
        }
        if (isNaN(numCols) || numCols < 3 || numCols > 15) {
          alert("Board columns must be between 3 and 15.");
          boardSizeColsInput.value = Math.max(3, Math.min(15, numCols || 5));
          return;
        }
        lockedTilePercentage = parseFloat(lockedLevelSelect.value);
        generatePuzzle();
      });

      // Initial puzzle
      generatePuzzle();
    </script>
  </body>
</html>
