import {
  Direction,
  GridState,
  PuzzleState,
  SpecialType,
  TileState,
  TileType,
} from "../types/types";

// --- Rotation Helpers ---

const DIRS: Record<Direction, [number, number]> = {
  up: [-1, 0],
  right: [0, 1],
  down: [1, 0],
  left: [0, -1],
};

const DIR_LIST: Direction[] = ["up", "right", "down", "left"];
const ROTATION_ORDER: number[] = [0, 90, 180, 270];

/** Checks if two arrays are equal */
function arraysEqual<T>(a: T[], b: T[]): boolean {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}

/** Rotates a single direction by a given angle */
export function rotateDir(d: Direction, ang: number): Direction {
  const index = DIR_LIST.indexOf(d);
  const newIndex = (index + ang / 90) % 4;
  return DIR_LIST[newIndex < 0 ? newIndex + 4 : newIndex];
}

/** Finds the correct rotation angle for a tile type to match target connections */
function rotateFor(
  defaultConnections: Direction[],
  targetConnections: Direction[]
): number {
  const sortedTarget = [...targetConnections].sort();
  for (const ang of ROTATION_ORDER) {
    const rotatedConnections = defaultConnections
      .map((d) => rotateDir(d, ang))
      .sort();
    if (arraysEqual(rotatedConnections, sortedTarget)) {
      return ang;
    }
  }
  return 0; // Default if no match (shouldn't happen for valid path tiles)
}

/** Get the default connections for a tile type (at 0 rotation) */
function getDefaultConnections(type: TileType): Direction[] {
  switch (type) {
    case "straight":
      return ["right", "left"];
    case "curve":
      return ["up", "right"];
    case "end":
      return ["right"];
    default:
      return [];
  }
}

/** Get the current connections of a tile based on its type and rotation */
export function getCurrentConnections(tile: TileState): Direction[] {
  const defaultConns = getDefaultConnections(tile.type);
  return defaultConns.map((d) => rotateDir(d, tile.rotation));
}

// --- Pathfinding and Random Helpers ---
function getRandomInt(max: number): number {
  return Math.floor(Math.random() * max);
}

function shuffleArray<T>(array: T[]): T[] {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

/** Finds a random path using Randomized DFS */
function findRandomPathDFS(
  N: number,
  startPos: [number, number],
  endPos: [number, number]
): [number, number][] | null {
  const stack: { pos: [number, number]; path: [number, number][] }[] = [];
  const visited: boolean[][] = Array.from({ length: N }, () =>
    Array(N).fill(false)
  );

  stack.push({ pos: startPos, path: [startPos] });
  visited[startPos[0]][startPos[1]] = true;

  while (stack.length > 0) {
    const current = stack.pop(); // DFS explores one branch fully
    if (!current) continue;

    const { pos: currentPos, path: currentPath } = current;
    const [r, c] = currentPos;

    if (r === endPos[0] && c === endPos[1]) {
      return currentPath; // Found the end
    }

    const neighbors: [number, number][] = [];
    for (const dirKey in DIRS) {
      const dirVec = DIRS[dirKey as Direction];
      const nr = r + dirVec[0];
      const nc = c + dirVec[1];

      if (nr >= 0 && nr < N && nc >= 0 && nc < N && !visited[nr][nc]) {
        neighbors.push([nr, nc]);
      }
    }

    shuffleArray(neighbors); // Randomize order of exploration

    for (const neighborPos of neighbors) {
      visited[neighborPos[0]][neighborPos[1]] = true; // Mark visited when adding to stack
      stack.push({ pos: neighborPos, path: [...currentPath, neighborPos] });
    }
  }
  return null; // Path not found
}

// --- Puzzle Initialization ---
export function initPuzzle(size: number, lockedPercent: number): PuzzleState {
  const N = size;

  if (N <= 0) throw new Error("Puzzle size N must be positive.");
  // MIN_PUZZLE_SIZE from config is 3, so N=1 or N=2 won't be generated by ticketLogic.
  // However, defensive coding for direct calls to initPuzzle:
  if (N < 2 && !(N === 1)) {
    // Allow N=1 as a special single tile case for robustness, but less than 2 generally problematic for paths
    throw new Error(
      "Puzzle size N must be at least 2 for distinct start/end path, or 1 for single tile."
    );
  }

  let startPos: [number, number];
  let endPos: [number, number];

  if (N === 1) {
    startPos = [0, 0];
    endPos = [0, 0];
  } else {
    let attempts = 0;
    const MAX_POS_ATTEMPTS = 100;
    do {
      startPos = [getRandomInt(N), getRandomInt(N)];
      endPos = [getRandomInt(N), getRandomInt(N)];
      attempts++;
      if (attempts > MAX_POS_ATTEMPTS) {
        console.warn(
          "Max attempts reached for start/end pos selection. Using potentially close points."
        );
        break;
      }
    } while (
      (startPos[0] === endPos[0] && startPos[1] === endPos[1]) || // Must be different
      // Ensure reasonable separation, scaled by N, with a min distance of 2 for N > 2
      Math.abs(startPos[0] - endPos[0]) + Math.abs(startPos[1] - endPos[1]) <
        Math.max(2, Math.floor(N * 0.3))
    );
  }

  const mainPathCoords =
    N === 1 ? [startPos] : findRandomPathDFS(N, startPos, endPos);

  if (!mainPathCoords || mainPathCoords.length === 0) {
    console.error(
      `Pathfinding failed between ${startPos} and ${endPos} on ${N}x${N} grid. This is unexpected.`
    );
    throw new Error(
      "Failed to generate random path for puzzle. Please try regenerating."
    );
  }

  const grid: GridState = Array.from({ length: N }, () =>
    Array(N)
      .fill(null)
      .map(() => ({
        type: "straight", // Placeholder
        correct: 0,
        rotation: 0,
        locked: true,
        special: null,
      }))
  );

  const pathCellSet = new Set<string>(
    mainPathCoords.map((p) => `${p[0]},${p[1]}`)
  );

  // Populate tiles on the main path
  for (let i = 0; i < mainPathCoords.length; i++) {
    const [r, c] = mainPathCoords[i];
    const connections: Direction[] = [];

    if (i > 0) {
      const [pr, pc] = mainPathCoords[i - 1];
      const dr = pr - r;
      const dc = pc - c;
      for (const dirKey in DIRS) {
        const d = dirKey as Direction;
        if (DIRS[d][0] === dr && DIRS[d][1] === dc) {
          connections.push(d);
          break;
        }
      }
    }

    if (i < mainPathCoords.length - 1) {
      const [nr, nc] = mainPathCoords[i + 1];
      const dr = nr - r;
      const dc = nc - c;
      for (const dirKey in DIRS) {
        const d = dirKey as Direction;
        if (DIRS[d][0] === dr && DIRS[d][1] === dc) {
          connections.push(d);
          break;
        }
      }
    }

    let type: TileType;
    if (connections.length === 0 && N === 1) {
      // Special case for 1x1 grid
      type = "end"; // A single tile is like an end piece.
    } else if (connections.length === 1) {
      type = "end";
    } else if (connections.length === 2) {
      const [d1, d2] = connections;
      const isOpposite =
        DIR_LIST.indexOf(d1) === (DIR_LIST.indexOf(d2) + 2) % 4 ||
        DIR_LIST.indexOf(d2) === (DIR_LIST.indexOf(d1) + 2) % 4;
      type = isOpposite ? "straight" : "curve";
    } else {
      console.warn(
        `Path cell [${r},${c}] has unexpected ${connections.length} connections.`
      );
      type = "end"; // Fallback
    }

    const defaultTileConns = getDefaultConnections(type);
    const correctRotation = rotateFor(defaultTileConns, connections);
    const isLocked = Math.random() * 100 < lockedPercent;
    const currentRotation = isLocked
      ? correctRotation
      : (correctRotation + (getRandomInt(3) + 1) * 90) % 360;
    const specialType: SpecialType =
      i === 0 ? "start" : i === mainPathCoords.length - 1 ? "end" : null;

    // If start and end are the same (1x1 grid), mark as 'start'. 'end' is implied.
    if (N === 1 && specialType === "end") {
      grid[r][c].special = "start"; // Override 'end' to 'start' for 1x1 consistency
    } else {
      grid[r][c].special = specialType;
    }
    grid[r][c].type = type;
    grid[r][c].correct = correctRotation;
    grid[r][c].rotation = currentRotation;
    grid[r][c].locked = isLocked;
  }

  // Populate filler tiles (not on the main path)
  for (let r_fill = 0; r_fill < N; r_fill++) {
    for (let c_fill = 0; c_fill < N; c_fill++) {
      if (!pathCellSet.has(`${r_fill},${c_fill}`)) {
        const randomTypeIndex = getRandomInt(3);
        const type: TileType =
          randomTypeIndex === 0
            ? "straight"
            : randomTypeIndex === 1
            ? "curve"
            : "end";
        const rotation = ROTATION_ORDER[getRandomInt(4)];

        grid[r_fill][c_fill] = {
          type,
          correct: rotation, // For locked filler tiles, current rotation is their "correct" one
          rotation,
          locked: true, // Filler tiles are always locked
          special: null,
        };
      }
    }
  }

  return { N, lockedPercent, grid };
}

// --- State Update Functions (Pure) ---
export function rotateTile(
  grid: GridState,
  r: number,
  c: number
): GridState | null {
  const tile = grid[r]?.[c];
  if (!tile || tile.locked) {
    return null;
  }
  const newGrid = grid.map((rowItem) => rowItem.map((cell) => ({ ...cell })));
  newGrid[r][c].rotation = (newGrid[r][c].rotation + 90) % 360;
  return newGrid;
}

// --- Solution Checking ---
/**
 * Checks if there's a valid path from the 'start' tile to the 'end' tile.
 * Ignores the state of filler tiles not part of this primary path.
 */
export function checkSolution(state: PuzzleState): boolean {
  const { N, grid } = state;
  let startCellPos: [number, number] | null = null;
  let endCellPos: [number, number] | null = null;

  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      if (grid[r][c].special === "start") {
        startCellPos = [r, c];
      }
      if (grid[r][c].special === "end") {
        endCellPos = [r, c];
      }
    }
  }

  // Handle 1x1 grid case: if start is defined and N=1, it's solved if tile is 'end' type.
  // The initPuzzle for N=1 sets special to 'start' and type to 'end'.
  if (N === 1 && startCellPos) {
    const tile = grid[startCellPos[0]][startCellPos[1]];
    // A 1x1 grid is "solved" if the single 'start' tile is an 'end' type and its rotation allows its single connection (if any)
    // For simplicity, we'll assume a 1x1 'start'/'end' tile is always solved if its basic type is 'end'.
    // Its `correct` rotation would be set during init. If it's not locked, it must be in `correct` rotation.
    return tile.type === "end" && tile.rotation === tile.correct;
  }

  if (!startCellPos || !endCellPos) {
    // console.log("Puzzle requires one 'start' and one 'end' tile.");
    return false;
  }
  if (
    startCellPos[0] === endCellPos[0] &&
    startCellPos[1] === endCellPos[1] &&
    N > 1
  ) {
    // console.log("Start and End tiles are the same, but grid is larger than 1x1. Invalid puzzle for pathfinding.");
    return false; // Path of length 0 not interesting for N > 1
  }

  // BFS/DFS to find path from start to end
  const queue: { pos: [number, number]; fromDir: Direction | null }[] = [
    { pos: startCellPos, fromDir: null },
  ];
  const visited = new Set<string>(); // "r,c"
  visited.add(`${startCellPos[0]},${startCellPos[1]}`);

  while (queue.length > 0) {
    const current = queue.shift();
    if (!current) continue;

    const [r, c] = current.pos;
    const tile = grid[r][c];
    const conns = getCurrentConnections(tile);

    // Validate current tile's connections based on its role (start, end, or intermediate)
    const isStartTile = r === startCellPos[0] && c === startCellPos[1];
    const isEndTile = r === endCellPos[0] && c === endCellPos[1];

    if (isStartTile || isEndTile) {
      if (conns.length !== 1) {
        // console.log(`Start/End tile at [${r},${c}] has ${conns.length} connections, expected 1.`);
        return false; // Start/End must have exactly one connection used in the path
      }
    } else {
      // Intermediate path tile
      if (conns.length !== 2) {
        // console.log(`Intermediate tile at [${r},${c}] has ${conns.length} connections, expected 2.`);
        return false; // Intermediate tiles must have two connections (in and out)
      }
    }

    for (const dir of conns) {
      // For start tile, any of its connections can be the first step.
      // For other tiles, avoid going back immediately unless it's the only option (which shouldn't happen for 2-connection tiles)
      if (
        current.fromDir &&
        dir === DIR_LIST[(DIR_LIST.indexOf(current.fromDir) + 2) % 4] &&
        conns.length > 1
      ) {
        continue;
      }

      const [dr, dc] = DIRS[dir];
      const nr = r + dr;
      const nc = c + dc;

      // Check if this neighbor is the end tile
      if (nr === endCellPos[0] && nc === endCellPos[1]) {
        const endTile = grid[nr][nc];
        const endTileConns = getCurrentConnections(endTile);
        const requiredConnFromEnd = DIR_LIST[(DIR_LIST.indexOf(dir) + 2) % 4]; // End tile must connect back
        if (
          endTileConns.length === 1 &&
          endTileConns.includes(requiredConnFromEnd)
        ) {
          return true; // Path found and validated
        } else {
          // console.log(`Reached End tile [${nr},${nc}] but its connections are invalid. Conns: ${endTileConns}, required: ${requiredConnFromEnd}`);
          continue; // Path leads to end, but end tile is not correctly oriented/typed
        }
      }

      // Check bounds for non-end neighbors
      if (nr < 0 || nr >= N || nc < 0 || nc >= N) continue; // Path leads out of bounds

      const neighborKey = `${nr},${nc}`;
      if (visited.has(neighborKey)) continue; // Already visited this tile in current path search

      const neighborTile = grid[nr][nc];
      // Neighbor must connect back to current tile
      const requiredConnFromNeighbor =
        DIR_LIST[(DIR_LIST.indexOf(dir) + 2) % 4];
      if (
        !getCurrentConnections(neighborTile).includes(requiredConnFromNeighbor)
      ) {
        // console.log(`Path broken at [${r},${c}] to [${nr},${nc}]. Neighbor doesn't connect back properly.`);
        continue; // This connection is a dead end or misaligned
      }

      // If neighbor is also special (not the target end), it's an error (e.g. another start)
      if (
        neighborTile.special &&
        !(nr === endCellPos[0] && nc === endCellPos[1])
      ) {
        // console.log(`Path encounters an unexpected special tile at [${nr},${nc}]`);
        continue;
      }

      visited.add(neighborKey);
      queue.push({ pos: [nr, nc], fromDir: dir });
    }
  }

  return false; // No valid path found from start to end
}
